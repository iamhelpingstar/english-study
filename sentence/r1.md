Instead they seek an estimate of $f$ that gets as close to the data points as possible without being too rough or wiggly.

대신에, 너무 거칠거나 흔들리지 않으면서 가능한 한 데이터 포인트에 가까운 $f$의 추정치를 찾으려 합니다.

This approach does not impose any pre-specified model on $f$.

이 접근법은 $f$에 사전에 지정된 어떠한 모델도 강제하지 않습니다.

In order to fit a thin-plate spline, the data analyst must select a level of smoothness.

thin-plate spline을 적용하기 위해, 데이터 분석가는 부드러움의 수준을 선택해야 합니다.

Of the many methods that we examine in this book, some are less flexible, or more restrictive, in the sense that they can produce just a relatively small range of shapes to estimate f.

이 책에서 살펴보는 많은 방법들 중 일부는 f를 추정하기 위해 상대적으로 작은 범위의 형태만을 생성할 수 있다는 점에서 덜 유연하거나 더 제한적입니다.

It is also more interpretable than linear regression, because in the final model the response variable will only be related to a small subset of the predictors—namely, those with nonzero coefficient estimates.

또한 선형 회귀보다 해석하기 쉬운데, 이는 최종 모델에서 반응 변수가 예측 변수의 작은 부분집합, 즉 0이 아닌 계수 추정치를 가진 것들과만 관련되기 때문입니다.

Surprisingly, this is not always the case!

놀랍게도, 이것이 항상 그런 것은 아닙니다!

This phenomenon, which may seem counterintuitive at first glance, has to do with the potential for overfitting in highly flexible methods.

처음 보기에는 직관에 반하는 것처럼 보일 수 있는 이 현상은 매우 유연한 방법에서 과적합(overfitting)의 가능성과 관련이 있습니다.

In this example, this wouldn’t actually help speed anyway, for many reasons, but treat this as a toy model of wanting to JIT-compile the update of model parameters, where `jax.jit` makes an enormous difference.

이 예시에서는 여러 이유로 실제로 속도를 향상시키지는 못하지만, 이것을 모델 매개변수의 업데이트를 JIT 컴파일하고자 하는 장난감 모델로 취급하세요, 여기서 `jax.jit` 는 엄청난 차이를 만듭니다.

This won’t do.

이렇게 하면 안 됩니다.

Part of the problem with our counter was that the returned value didn’t depend on the arguments, meaning a constant was “baked into” the compiled output.

우리 카운터의 문제점 중 일부는 반환된 값이 인수에 의존하지 않아 컴파일된 출력에 상수가 "내장되었다"는 것이었습니다.

The most important difference, and in some sense the root of all the rest, is that JAX is designed to be functional, as in functional programming.

가장 중요한 차이점이자, 어떤 의미에서 모든 다른 차이의 근원은 JAX가 함수형 프로그래밍처럼 함수형으로 설계되었다는 것입니다.

This is because any such side-effects will only be executed once, when the python version of the function is run during compilation.

이는 그러한 side-effect가 컴파일 중에 파이썬 버전의 함수가 실행될 때 단 한 번만 실행되기 때문입니다.

Part of the problem with our counter was that the returned value didn’t depend on the arguments, meaning a constant was “baked into” the compiled output.

우리 카운터의 문제점 중 일부는 반환된 값이 인수에 의존하지 않아 컴파일된 출력에 상수가 "내장되었다"는 것이었습니다.

Notice that the need for a class becomes less clear once we have rewritten it this way. We could just keep `stateless_method`, since the class is no longer doing any work. This is because, like the strategy we just applied, object-oriented programming (OOP) is a way to help programmers understand program state.

이렇게 다시 작성하면 클래스의 필요성이 덜 명확해집니다. 클래스가 더 이상 작업을 수행하지 않기 때문에 `stateless_method`만 유지할 수 있습니다. 이는 우리가 방금 적용한 전략과 마찬가지로, 객체 지향 프로그래밍(OOP)이 프로그래머가 프로그램 상태를 이해하는 데 도움을 주는 방법이기 때문입니다.

Here, we only deal with one kind of state: the model parameters. But generally, you’ll see many kinds of state being threaded in and out of JAX functions, like optimizer state, layer statistics for batchnorm, and others.

여기서는 모델 매개변수라는 한 종류의 상태만 다룹니다. 하지만 일반적으로 JAX functions, optimizer state, batchnorm을 위한 layer statistics 등과 같은 여러 종류의 상태가 JAX 함수에 들어가고 나오는 것을 볼 수 있습니다.

Are we supposed to initialize them all manually, essentially repeating what we already write in the forward pass definition?

우리는 기본적으로 순방향 패스 정의에서 이미 작성한 것을 반복하면서 모두 수동으로 초기화해야 하는 것인가요?

Greater difficulties arise when the environment changes to become better than it was before, and yet the formerly correct policy does not reveal the improvement. In these cases the modeling error may not be detected for a long time, if ever.

환경이 이전보다 개선되기 위해 바뀌었지만 이전에 올바른 정책이 개선된 점을 드러내지 않을 때 더 큰 어려움이 발생합니다. 이러한 경우 모델링 오류가 오랫동안 감지되지 않을 수 있습니다.

In a stochastic environment, variations in estimated transition probabilities also contribute to variations in the sizes of changes and in the urgency with which pairs need to be updated.

확률적 환경에서 추정된 전이 확률의 변화는 변화의 크기와 쌍을 업데이트해야 하는 긴급도의 변화에도 기여합니다.

The important feature of functional programming to grok when working with JAX is very simple: don’t write code with side-effects.

JAX를 사용할 때 이해해야 할 함수형 프로그래밍의 중요한 특징은 매우 간단합니다: side-effects가 있는 코드를 작성하지 마세요.

In this example, this wouldn’t actually help speed anyway, for many reasons, but treat this as a toy model of wanting to JIT-compile the update of model parameters, where `jax.jit` makes an enormous difference.

이 예시에서는 여러 이유로 실제로 속도를 향상시키지는 못하지만, 이것을 모델 매개변수의 업데이트를 JIT 컴파일하고자 하는 장난감 모델로 취급하세요, 여기서 `jax.jit`는 엄청난 차이를 만듭니다.

Implicit in that point of view is that expected updates, if possible, are preferable to sample updates.

이러한 관점에 내재된 생각은, 가능하기만 하다면 기댓값 갱신이 표본 갱신보다 더 선호할 만하다는 것이다.

The difference between these expected and sample updates is significant to the extent that the environment is stochastic, specifically, to the extent that, given a state and action, many possible next states may occur with various probabilities.

환경이 확률론적인 경우에 한해, 좀 더 분명히 말하면 상태와 행동이 주어졌을 때 가능성 있는 많은 다음 상태들이 다양한 확률로 발생할 수 있는 경우에 한해, 이러한 기댓값 갱신과 표본 갱신의 차이점은 중요한 의미를 갖는다.

The sample update is in addition affected by sampling error. On the other hand, the sample update is cheaper computationally because it considers only one next state, not all possible next states.

표본 갱신은 추가로 표본 오차에 의한 영향을 받는다. 반면에, 표본 오차는 가능한 모든 다음 상태가 아니라 오직 하나의 다음 상태만을 고려하기 때문에 많은 계산을 필요로 하지 않는다.

Given a unit of computational effort, is it better devoted to a few expected updates or to b times as many sample updates?

한 단위의 계산량이 몇 개의 기댓값 갱신에 사용되는 것이 좋은가? 아니면 개수가 b배인 표본 갱신에 사용되는 것이 좋은가?

For these cases, many state–action pairs could have their values improved dramatically, to within a few percent of the effect of an expected update, in the same time that a single state–action pair could undergo an expected update.

이 경우에 많은 수의 상태-행동 쌍들은 기댓값 갱신이 가치를 향상시키는 효과의 몇 퍼센트 이내로 그들의 가치를 극적으로 향상시킬 수 있었을 것이다. 하지만 이때 소요되는 시간은 고작 하나의 상태-행동 쌍이 기댓값 갱신을 수행하는 시간과 같은 시간이다.

