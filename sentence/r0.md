Greater difficulties arise when the environment changes to become better than it was before, and yet the formerly correct policy does not reveal the improvement. In these cases the modeling error may not be detected for a long time, if ever.

환경이 이전보다 개선되기 위해 바뀌었지만 이전에 올바른 정책이 개선된 점을 드러내지 않을 때 더 큰 어려움이 발생합니다. 이러한 경우 모델링 오류가 오랫동안 감지되지 않을 수 있습니다.

In a stochastic environment, variations in estimated transition probabilities also contribute to variations in the sizes of changes and in the urgency with which pairs need to be updated.

확률적 환경에서 추정된 전이 확률의 변화는 변화의 크기와 쌍을 업데이트해야 하는 긴급도의 변화에도 기여합니다.

The important feature of functional programming to grok when working with JAX is very simple: don’t write code with side-effects.

JAX를 사용할 때 이해해야 할 함수형 프로그래밍의 중요한 특징은 매우 간단합니다: side-effects가 있는 코드를 작성하지 마세요.

In this example, this wouldn’t actually help speed anyway, for many reasons, but treat this as a toy model of wanting to JIT-compile the update of model parameters, where `jax.jit` makes an enormous difference.

이 예시에서는 여러 이유로 실제로 속도를 향상시키지는 못하지만, 이것을 모델 매개변수의 업데이트를 JIT 컴파일하고자 하는 장난감 모델로 취급하세요, 여기서 `jax.jit`는 엄청난 차이를 만듭니다.

Implicit in that point of view is that expected updates, if possible, are preferable to sample updates.

이러한 관점에 내재된 생각은, 가능하기만 하다면 기댓값 갱신이 표본 갱신보다 더 선호할 만하다는 것이다.

The difference between these expected and sample updates is significant to the extent that the environment is stochastic, specifically, to the extent that, given a state and action, many possible next states may occur with various probabilities.

환경이 확률론적인 경우에 한해, 좀 더 분명히 말하면 상태와 행동이 주어졌을 때 가능성 있는 많은 다음 상태들이 다양한 확률로 발생할 수 있는 경우에 한해, 이러한 기댓값 갱신과 표본 갱신의 차이점은 중요한 의미를 갖는다.

The sample update is in addition affected by sampling error. On the other hand, the sample update is cheaper computationally because it considers only one next state, not all possible next states.

표본 갱신은 추가로 표본 오차에 의한 영향을 받는다. 반면에, 표본 오차는 가능한 모든 다음 상태가 아니라 오직 하나의 다음 상태만을 고려하기 때문에 많은 계산을 필요로 하지 않는다.

Given a unit of computational effort, is it better devoted to a few expected updates or to b times as many sample updates?

한 단위의 계산량이 몇 개의 기댓값 갱신에 사용되는 것이 좋은가? 아니면 개수가 b배인 표본 갱신에 사용되는 것이 좋은가?

For these cases, many state–action pairs could have their values improved dramatically, to within a few percent of the effect of an expected update, in the same time that a single state–action pair could undergo an expected update.

이 경우에 많은 수의 상태-행동 쌍들은 기댓값 갱신이 가치를 향상시키는 효과의 몇 퍼센트 이내로 그들의 가치를 극적으로 향상시킬 수 있었을 것이다. 하지만 이때 소요되는 시간은 고작 하나의 상태-행동 쌍이 기댓값 갱신을 수행하는 시간과 같은 시간이다.

